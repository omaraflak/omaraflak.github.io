<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Virtual Machine</title>
    <link rel="icon" type="image/svg+xml" href="/images/favicon.svg">
    <link rel="stylesheet" href="../styles/index.css">
    <link rel="stylesheet" href="../styles/fonts.css">
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.9/katex.min.css" integrity="sha512-fHwaWebuwA7NSF5Qg/af4UeDx9XqUpYpOGgubo3yWu+b2IQR4UeQwbb42Ti7gVAjNtVoI/I9TEoYeu9omwcC6g==" crossorigin="anonymous" referrerpolicy="no-referrer" />
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.11.1/styles/github.min.css" integrity="sha512-0aPQyyeZrWj9sCA46UlmWgKOP0mUipLQ6OZXu8l4IcAmD2u31EPEy9VcIMvl7SoAaKe8bLXZhYoMaE/in+gcgA==" crossorigin="anonymous" referrerpolicy="no-referrer" />
</head>

<body>
    <div class="site-header">
        <div class="site-header-content">
            <a href="/index.html" class="site-header-link">Home</a>
            <a href="/articles.html" class="site-header-link">Blog</a>
        </div>
    </div>
    <div class="article-header">
        <div class="article-header-content">
            <h1 class="article-title">Virtual Machine</h1>
            <p class="article-description">What is a virtual machine and how to create one?</p>
            <p class="article-date">Aug 11, 2025</p>
            
        </div>
    </div>
    <main class="article-main">
        <article class="article-body">
            <p>Virtual machines are a truely fascinating piece of software, and yet suprisingly simple. As you start understanding how they work and write your own, it will feel like you're discovering computers all over again. In this article I will explain what a virtual machine is and how to bulid one, we will write some code that runs on our virtual machine, and see how simple constructs build up to create complex logic.</p>
<h2 id=preamble class="article-section">Preamble</h2>
<p>Your computer has a processor, or CPU (central processing unit), which is responsible for executing instructions, performing calculations, moving memory around, etc. It's the central piece of your computer, and yet at its core, you could reduce it to something very simple.</p>
<div class="article-quote">A CPU is a machine that takes <span class="article-bold">instructions</span> as input, and executes <span class="article-bold">actions</span> as output.</div>
<p>Those <span class="article-italic">instructions</span> are very basic. An instruction might add two numbers, multiply two numbers, read from a memory location, write to a memory location, etc.</p>
<p>When a program executes on your computer, it can go through convoluted paths involving various optimizations and pre-processing, but evenutally it <span class="article-bold">must</span> be transformed into instructions for the CPU to understand and execute.</p>
<div class="article-quote">A virtual machine, VM, is a simulation of a CPU.</div>
<p>This simulation can be more or less complex, support more or less instructions, but the main idea stays the same.</p>
<p>There are multiple types of VM architectures, mainly: stack-based, register-based, or hybrid. In this article we will be playing around with a <span class="article-italic">hybrid</span> model.</p>
<h2 id=programming-languages class="article-section">Programming Languages</h2>
<p>CPUs come in various kinds and architectures (for example because of their brands). The instructions a given CPU support are thus not necessarily the same than other CPUs. This means that when you compile code into an executable, it has to be compiled <span class="article-italic">for a given CPU instruction set</span>.</p>
<p>Languages such as C or C++ compile directly into machine code (CPU instructions), which means they run very fast, but it also means you have to write <span class="article-bold">one compiler per CPU architecture to target</span>.</p>
<p>Other languages, like Java, are based on virtual machines. For Java it's the <span class="article-bold">Java Virtual Machine</span>, or JVM. This means that code written in Java does not compile into CPU instructions directly, but instead it compiles into <span class="article-bold">VM instructions</span> (here, the JVM)! It is then the job of the JVM (which is just another piece of software) to read and execute the instructions. This means it is slower to execute since we've introduced a "middle-man" between the code and the CPU, which is the VM. In other words, the code runs on the JVM, which runs on the CPU.</p>
<p>In return, the advantages of this approach are multiple:</p>
<ul><li class="article-li">Any system that has the VM can run your code (so you don't have to write a compiler for each CPU architecture)</li>
<li class="article-li">Anyone can create a new progamming language syntax and compile their code into your VM's instruction set (e.g. Scala, Kotlin, and more, run on the JVM)</li>
<li class="article-li">Easier to maintain, extend, and debug</li></ul>
<h2 id=virtual-machine class="article-section">Virtual Machine</h2>
<p>Our virtual machine will have those components:</p>
<ul><li class="article-li">A <span class="article-bold">stack</span> which holds temporary values for calculations, e.g. when computing <code class="article-code-inline">x=1+2</code>.</li>
<li class="article-li">A <span class="article-bold">memory</span> which holds persistent values in a given scope.</li>
<li class="article-li">A <span class="article-bold">program</span> which it has to run (a set of instructions).</li>
<li class="article-li">An <span class="article-bold">instruction pointer</span> which points to the current instruction in the <span class="article-italic">program</span> that is being executed.</li></ul>
<p>This will be our instruction set:</p>
<ul><li class="article-li"><span class="article-bold"><code class="article-code-inline">push &lt;value&gt;</code></span> pushes a value to the stack.</li>
<li class="article-li"><span class="article-bold"><code class="article-code-inline">store &lt;address&gt;</code></span> pops a value from the stack and stores it at the given address in the memory.</li>
<li class="article-li"><span class="article-bold"><code class="article-code-inline">load &lt;address&gt;</code></span> reads a value at the given address from the memory and pushes it onto the stack.</li>
<li class="article-li"><span class="article-bold"><code class="article-code-inline">add</code></span> pops two elements from the stack, computes the sum, and pushes the result onto the stack.</li>
<li class="article-li"><span class="article-bold"><code class="article-code-inline">sub</code></span> pops two elements from the stack, computes the difference between the second and the first, and pushes the result onto the stack.</li>
<li class="article-li"><span class="article-bold"><code class="article-code-inline">jumpif &lt;address&gt;</code></span> pops an element stack, and moves the instruction pointer to the given address if the value is greater than zero.</li>
<li class="article-li"><span class="article-bold"><code class="article-code-inline">print</code></span> pops an element from the stack and prints it to stdout.</li>
<li class="article-li"><span class="article-bold"><code class="article-code-inline">halt</code></span> stops the virtual machine.</li></ul>
<p><code class="article-code-inline">value</code> and <code class="article-code-inline">address</code> will be <span class="article-bold">int32</span> (4 bytes).</p>
<p>Here's a starter Python code:</p>
<pre class="article-code-block python"><code>import dataclasses

class Op:
    PUSH = 0
    STORE = 1
    LOAD = 2
    ADD = 3
    SUB = 4
    JUMPIF = 5
    PRINT = 6
    HALT = 7

@dataclasses.dataclass
class Vm:
    program: bytes
    stack: list[int]
    memory: list[int]
    ip: int = 0

    def run(self):
        while self.ip < len(self.program):
            instruction = self.program[self.ip]
            # TODO: process instruction

program = [] # instructions to execute
vm = Vm(program=program, stack=[], memory=[0] * 32)
vm.run()</code></pre>
<p><span class="article-bold">Challenge!</span> Can you complete writing the code of the virtual machine on your own? (Remeber that <span class="article-italic">values</span> and <span class="article-italic">addresses</span> in the program are written over 4 bytes).</p>
<p>When you do, feed in the following program to get a surprise!</p>
<pre class="article-code-block python"><code>program = [0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 0, 1, 0, 0, 0, 0, 0, 1, 0, 0, 0, 2, 2, 0, 0, 0, 0, 2, 0, 0, 0, 1, 3, 1, 0, 0, 0, 3, 2, 0, 0, 0, 3, 6, 2, 0, 0, 0, 1, 1, 0, 0, 0, 0, 2, 0, 0, 0, 3, 1, 0, 0, 0, 1, 2, 0, 0, 0, 2, 0, 0, 0, 0, 1, 3, 1, 0, 0, 0, 2, 0, 0, 0, 0, 20, 2, 0, 0, 0, 2, 4, 5, 0, 0, 0, 30, 7]</code></pre>
<h3 id=code class="article-small-section">Code</h3>
<p>Here's the full code:</p>
<pre class="article-code-block python"><code>import dataclasses

class Op:
    PUSH = 0
    STORE = 1
    LOAD = 2
    ADD = 3
    SUB = 4
    JUMPIF = 5
    PRINT = 6
    HALT = 7

@dataclasses.dataclass
class Vm:
    program: bytes
    stack: list[int]
    memory: list[int]
    ip: int = 0

    def push(self, value: int):
        self.stack.append(value)

    def store(self, index: int):
        self.memory[index] = self.stack.pop()

    def load(self, index: int):
        self.stack.append(self.memory[index])

    def add(self):
        a = self.stack.pop()
        b = self.stack.pop()
        self.stack.append(a + b)

    def sub(self):
        a = self.stack.pop()
        b = self.stack.pop()
        self.stack.append(b - a)

    def jumpif(self, pointer: int):
        if self.stack.pop() > 0:
            self.ip = pointer

    def print(self):
        print(self.stack.pop())

    def run(self):
        while self.ip < len(self.program):
            instruction = self.program[self.ip]
            self.ip += 1

            if instruction == Op.PUSH:
                self.push(self._read_int32())
            elif instruction == Op.STORE:
                self.store(self._read_int32())
            elif instruction == Op.LOAD:
                self.load(self._read_int32())
            elif instruction == Op.ADD:
                self.add()
            elif instruction == Op.SUB:
                self.sub()
            elif instruction == Op.JUMPIF:
                self.jumpif(self._read_int32())
            elif instruction == Op.PRINT:
                self.print()
            elif instruction == Op.HALT:
                break
            else:
                raise ValueError(f"Instruction not supported: {instruction}")

    def _read_int32(self) -> int:
        return self._read_int(4)

    def _read_int(self, size: int) -> int:
        data = self.program[self.ip: self.ip + size]
        self.ip += size
        return int.from_bytes(bytes(data))</code></pre>
<p>And if you run the previous program you will see... the <span class="article-bold">fibonacci</span> sequence! How?!</p>
<p>Let's understand how this works by examples. I wrote a small assembler program which allows us to write instructions using their name. Anything following a <code class="article-code-inline">#</code> is a comment.</p>
<h3 id=example-1 class="article-small-section">Example 1</h3>
<textarea style="width: 100%; height: 200px; resize: vertical;" id="assembly1"></textarea>
<input id="execute1" type="button" value="Run">
<div class="article-code-output" id="output1"></div>
<h3 id=example-2 class="article-small-section">Example 2</h3>
<p>I have also introduced a label mechanism in the assembler program so we don't have to pass the actual index of the instruction to <code class="article-code-inline">jumpif</code>. To define a label, write down a dot <code class="article-code-inline">.</code> followed by the name of the label, e.g. <code class="article-code-inline">.mylabel</code>. Then use it as <code class="article-code-inline">jumpif .mylabel</code>.</p>
<textarea style="width: 100%; height: 200px; resize: vertical;" id="assembly2"></textarea>
<input id="execute2" type="button" value="Run">
<div class="article-code-output" id="output2"></div>
<h3 id=fibonacci class="article-small-section">Fibonacci</h3>
<p>All I did earlier was to translate the following logic into bytecode for our VM:</p>
<pre class="article-code-block python"><code>a = 0
b = 1
n = 20

for i in range(n):
    c = a + b
    print(c)
    a = b
    b = c</code></pre>
<textarea style="width: 100%; height: 200px; resize: vertical;" id="assembly3"></textarea>
<input id="execute3" type="button" value="Run">
<div class="article-code-output" id="output3"></div>
<h2 id=programming-constructs class="article-section">Programming Constructs</h2>
<p>Hopefully you are starting to see how using those simple instructions we can build up to what we have in today's programming languages. In this section we will see how to build common programming constructs.</p>
<h3 id=if-condition class="article-small-section">If Condition</h3>
<p>An <code class="article-code-inline">if</code>-condition is a construct that executes a code-block <span class="article-bold">if</span> a certain condition is true, otherwise the program should jump to the instructions after the condition block.</p>
<pre class="article-code-block None"><code># evaluate a condition, push the result in the stack
# stack=[...,x] with x>0 if the condition evaluated to `true`
jumpifnot .endif
# if-block...
.endif</code></pre>
<p>Where <code class="article-code-inline">jumpifnot</code> is the opposite of <code class="article-code-inline">jumpif</code>: it will jump if the top element in the stack is <code class="article-code-inline">&lt;= 0</code>.</p>
<h3 id=while-loops class="article-small-section">While Loops</h3>
<p>A <code class="article-code-inline">while</code>-loop is a constructs that repeats a code-block <span class="article-bold">while</span> a certain condition is true. When the condition stop being true, then program should jump to the end of the while block.</p>
<pre class="article-code-block None"><code>.while
# evaluate a condition, push the result in the stack
# stack=[...,x] with x>0 if the condition evaluated to `true`
jumpifnot .endwhile
# while-block...
jump .while
.endwhile</code></pre>
<p>Where <code class="article-code-inline">jump</code> is an unconditional jump: it moves the instruction pointer regardless of what's in the stack.</p>
<h3 id=functions class="article-small-section">Functions</h3>
<p>Functions are nothing but a place in section of the bytecode that we jump to and back. The question is: how does the function code know where to jump back if it can be invoked from many different places?</p>
<p>In practice we would have a different stack for function calls, in which we push the address of the caller before jumping to a function. Whenever the function <span class="article-bold"><span class="article-italic">returns</span></span>, it pops an element from the call stack and jumps to that address (so it <span class="article-italic">returns</span> to the caller).</p>
<pre class="article-code-block None"><code># main program
call .myfunction
# ...
# ...
.myfunction
# function body
return</code></pre>
<p>Where <code class="article-code-inline">call</code> pushes the current instruction pointer + 1 to the call stack, and <code class="article-code-inline">return</code> pops an element from the call stack and <code class="article-code-inline">jump</code> to it.</p>
<h2 id=how-to-build-a-programming-language class="article-section">How To Build A Programming Language</h2>
<p>Building a VM-based programming language is really not that hard once you understand those concepts. As you implement more instructions in your VM and understand how to map the high-level constructs to those instructions, what remains is how to translate code written in a high-level syntax into the low-level bytecode for your VM.</p>
<p>The steps are generally the following</p>
<h3 id=1-tokenizer class="article-small-section">1. Tokenizer</h3>
<p>A <span class="article-italic">tokenizer</span> will first run over your high-level code and build a list of <span class="article-italic">tokens</span> out of it. For example:</p>
<pre class="article-code-block c"><code>int multiply(int a, int b) {
    return a * b;
}</code></pre>
<p>Will return tokens: <code class="article-code-inline">int</code>, <code class="article-code-inline">multiply</code>, <code class="article-code-inline">(</code>, <code class="article-code-inline">int</code>, <code class="article-code-inline">a</code>, <code class="article-code-inline">,</code>, <code class="article-code-inline">int</code>, <code class="article-code-inline">b</code>, <code class="article-code-inline">)</code>, <code class="article-code-inline">{</code>, <code class="article-code-inline">return</code>, <code class="article-code-inline">a</code>, <code class="article-code-inline">*</code>, <code class="article-code-inline">b</code>, <code class="article-code-inline">;</code>, <code class="article-code-inline">}</code>.</p>
<p>Notice that this is not a simple split-by-space, but not too far from it. The tokenizer will generally assign a type to each token, e.g. <code class="article-code-inline">STRING</code>, <code class="article-code-inline">NUMBER</code>, <code class="article-code-inline">LEFT_PARENTHESIS</code>, <code class="article-code-inline">RIGHT_PARENTHESIS</code>, <code class="article-code-inline">IDENTIFIER</code>, etc.</p>
<h3 id=2-abstract-syntax-tree class="article-small-section">2. Abstract Syntax Tree</h3>
<p>The tokens from the previous step are then used to build an <span class="article-italic">Abastract Syntax Tree</span>, AST. The AST represents the <span class="article-bold">logic</span> of your code in a way that is independent from the syntax of your language. Essentially, this is a Tree structure, with <code class="article-code-inline">IF</code>-nodes, <code class="article-code-inline">WHILE</code>-nodes, and such.</p>
<p>For example, this AST represents <code class="article-code-inline">a=b+3</code>.</p>
<center><div class="article-graphviz">digraph AST {
    // General node style: rounded boxes
    node [shape=box, style=rounded, fontname="Inter"];
    edge [fontname="Inter"];

    // Define the nodes of the tree
    // We give them simple names (node0, node1, etc.) and descriptive labels.
    node0 [label="Assign\n="];
    node1 [label="Identifier\n(a)"];
    node2 [label="Binary Op\n+"];
    node3 [label="Identifier\n(b)"];
    node4 [label="Literal\n(3)"];

    // Define the edges (connections) between the nodes
    // This shows the structure of the expression.

    // The root is the assignment operator
    node0 -> node1; // The left child of '=' is the variable 'a'
    node0 -> node2; // The right child of '=' is the expression 'b + 3'

    // The children of the addition operator
    node2 -> node3; // The left child of '+' is the variable 'b'
    node2 -> node4; // The right child of '+' is the number '3'
}</div></center>
<h3 id=3-compiler class="article-small-section">3. Compiler</h3>
<p>Lastly, a <span class="article-italic">compiler</span> converts the AST into bytecode for your virtual machine, which can then run the code. This is great because any person who wants to create a new language syntax for your VM only has to compile it to an AST. In fact, you could use any existing AST builder, and then convert code to your VM's bytecode.</p>
<p>A few years ago I built a toy programming language this way. Check it out!</p>

                    <div class="article-link-preview-container">
                        <a class="article-link-preview-link" target="_blank" href="https://github.com/omaraflak/banana">
                            <span class="article-link-preview-title">GitHub - omaraflak/banana: Banana programming language</span>
                            <span class="article-link-preview-description">Banana programming language. Contribute to omaraflak/banana development by creating an account on GitHub.</span>
                            <span class="article-link-preview-website">github.com</span>
                        </a>
                    </div>
                
<script src="/assets/virtual-machine/vm.js"></script>
        </article>
    </main>
    <div class="article-hr"></div>
    <div class="site-footer">
        <div class="site-footer-content"></div>
    </div>
    <script defer src="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.9/katex.min.js" integrity="sha512-LQNxIMR5rXv7o+b1l8+N1EZMfhG7iFZ9HhnbJkTp4zjNr5Wvst75AqUeFDxeRUa7l5vEDyUiAip//r+EFLLCyA==" crossorigin="anonymous" referrerpolicy="no-referrer"></script>
    <script defer src="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.9/contrib/auto-render.min.js" integrity="sha512-iWiuBS5nt6r60fCz26Nd0Zqe0nbk1ZTIQbl3Kv7kYsX+yKMUFHzjaH2+AnM6vp2Xs+gNmaBAVWJjSmuPw76Efg==" crossorigin="anonymous" referrerpolicy="no-referrer" onload="renderMathInElement(document.body, {
        delimiters: [
            {left: '[begin-latex]', right: '[end-latex]', display: true},
            {left: '[begin-latex-inline]', right: '[end-latex-inline]', display: false},
        ]
    });"></script>
    <script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.11.1/highlight.min.js" integrity="sha512-EBLzUL8XLl+va/zAsmXwS7Z2B1F9HUHkZwyS/VKwh3S7T/U0nF4BaU29EP/ZSf6zgiIxYAnKLu6bJ8dqpmX5uw==" crossorigin="anonymous" referrerpolicy="no-referrer" onload="hljs.highlightAll();"></script>
    <script defer src="https://cdnjs.cloudflare.com/ajax/libs/viz.js/2.1.2/viz.js" integrity="sha512-vnRdmX8ZxbU+IhA2gLhZqXkX1neJISG10xy0iP0WauuClu3AIMknxyDjYHEpEhi8fTZPyOCWgqUCnEafDB/jVQ==" crossorigin="anonymous" referrerpolicy="no-referrer"></script>
    <script defer src="https://cdnjs.cloudflare.com/ajax/libs/viz.js/2.1.2/lite.render.js" integrity="sha512-uAHj1knkgGpl0fJcyjbcVY0f9j252eWzEeBxE4s4AQkPJkp/+U+rlfoOXlwreSzPhndCT+5YR00/QSD/nPqb+g==" crossorigin="anonymous" referrerpolicy="no-referrer" onload="
        const viz = new Viz();
        document.querySelectorAll('.article-graphviz').forEach(element => {
            const content = element.textContent;
            try {
                viz.renderSVGElement(content)
                    .then(svg => {
                        element.textContent = '';
                        element.appendChild(svg);
                    })
                    .catch(error => {
                        console.error('Error rendering Graphviz SVG:', error);
                        element.textContent = 'Error rendering graph. Check console for details.';
                    });
            } catch (error) {
                console.error('Error with Viz.js rendering process:', error);
                element.textContent = 'Error during graph rendering setup.';
            }
        });
    "></script>
</body>

</html>